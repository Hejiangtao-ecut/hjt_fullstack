算法中最大占比动态规化 DB
建立感性认识,具象去学习 抽象不好学习

- 爬楼梯 
    n阶
    1阶或2阶 不同的方法到顶
    2 2种
    3 3种 f(1)+f(2)
    买一本算法小册 记忆一些算法细节 geektime 算法
    自顶向下问题 划分成子问题来解决的话,树状结构,请使用递归
两个关键特征    
    1. 要求你给出达成某个目标的解法个数
    2. 不要求给出每种算法对应的具体路径


    3. 定位到问题的终点
    4. 站在这个终点,去考虑之前要做什么

    匹配了树状结构
    f(n)=f(n-1)+f(n+1) //顶部

- 有什么问题？

    递归
        1. 问题细化后解决方式类似,以树状结构自顶向下设计,找到递归公式
        2. 要有退出条件
        3. 需要优化

- 向下向上去解决的时候,就是动态规化 先记忆,很难把握
    站在已知的角度上,通过定位已知和未知之间的关系,一步一步向前推进
    求出未知的值

    读题 正常的想法 DP 最简单的DP 
    n = 1 n = 2
    n = 3 3
    n = 4 5 
    循环  公式也很明确 f(n)=f(n-1)+f(n-2)

- 动态规划是递归的下一站
    1. 自下向上
    2. 发现公式的眼睛,基于递归,来找到规律,
        状态转移公式
    之所以我们会放弃使用动态规化,选择递归来解决,是因为有些状态转移不明显

    不同面额的coins 和一个总金额amout
    conss =[1,2,5] amout=11
    所需的最小硬币个数
    动态思考解决的方式 最佳规化
    最值的问题一般是利用DP来解决

    自顶向下去思考下
    11 最少的硬币数
    上一次有多少钱 
    Math.min(f(n-c5)+1,f(n-c2)+1,f(n-c1)+1)
